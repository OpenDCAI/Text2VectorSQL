[
    {
        "db_id": "musical",
        "sql": "SELECT Musical_ID\nFROM musical\nWHERE Award_embedding MATCH lembed(all-MiniLM-L6-v2, \"Outstanding Musical Theater Award\") AND k = 5;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 5,
        "sql_complexity": "Simple",
        "question_style": "Formal",
        "sql_explanation": "The given SQL query retrieves the `Musical_IDs` of musical entries from the `musical` table where the `Award_embedding` vector matches a specified embedding for the concept of \"Outstanding Musical Theater Award\". This is performed using the `lembed` function combined with the `MATCH` operator, which is a vector search operation facilitated by the `sqlite-lembed` extension. The query aims to identify the five musical entries that best match this concept based on vector similarity.",
        "question": "Identify the top five musicals that are most recognized for an Outstanding Musical Theater Award and provide their musical IDs.",
        "external_knowledge": "",
        "sqlite_sql": "SELECT Musical_ID\nFROM musical\nWHERE Award_embedding MATCH lembed('all-MiniLM-L6-v2', \"Outstanding Musical Theater Award\") AND k = 5;",
        "postgresql_sql": "SELECT \"Musical_ID\", \"musical\".\"Award_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Outstanding Musical Theater Award') AS \"distance\"\nFROM \"musical\"\nORDER BY \"distance\"\nLIMIT 5;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Outstanding Musical Theater Award') AS ref_vec_0\n\nSELECT Musical_ID, L2Distance(musical.Award_embedding, ref_vec_0) AS distance\nFROM musical\nORDER BY distance\nLIMIT 5;",
        "integration_level": 1.0
    },
    {
        "db_id": "hospital_1",
        "sql": "SELECT m.Name\nFROM Medication m\nJOIN Prescribes p ON m.Code = p.Medication\nJOIN Physician ph ON p.Physician = ph.EmployeeID\nWHERE m.Description_embedding MATCH lembed(all-MiniLM-L6-v2, \"Effective treatment for pain and inflammation\") AND m.k = 3\nAND ph.Position = 'Specialist'\nORDER BY distance\nLIMIT 5;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 0,
        "sql_complexity": "Moderate",
        "question_style": "Interrogative",
        "sql_explanation": "The given SQL query is designed to find and return the names of medications that are most relevant to the description \"Effective treatment for pain and inflammation.\" This is performed using a vector search through embedding matching. Specifically, the query retrieves the top 3 medications (as indicated by `m.k = 3`) that match this description.\n\nThe search is restricted to medications prescribed by physicians who hold the position of 'Specialist'. The results are ordered based on similarity distance, ensuring that the most relevant medications appear first. Finally, the query limits the output to the top 5 medications according to this distance.",
        "question": "Could you provide the names of the top 5 medications that are most effective for treating pain and inflammation, specifically prescribed by specialist physicians?",
        "external_knowledge": "",
        "sqlite_sql": "SELECT m.Name\nFROM Medication m\nJOIN Prescribes p ON m.Code = p.Medication\nJOIN Physician ph ON p.Physician = ph.EmployeeID\nWHERE m.Description_embedding MATCH lembed('all-MiniLM-L6-v2', \"Effective treatment for pain and inflammation\") AND m.k = 3\nAND ph.Position = 'Specialist'\nORDER BY distance\nLIMIT 5;",
        "postgresql_sql": "SELECT \"m\".\"Name\", \"m\".\"Description_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Effective treatment for pain and inflammation') AS \"distance\"\nFROM \"Medication\" \"m\"\nJOIN \"Prescribes\" \"p\" ON \"m\".\"Code\" = \"p\".\"Medication\"\nJOIN \"Physician\" \"ph\" ON \"p\".\"Physician\" = \"ph\".\"EmployeeID\"\nWHERE   \"ph\".\"Position\" = 'Specialist'\nORDER BY \"distance\"\nLIMIT 3;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Effective treatment for pain and inflammation') AS ref_vec_0\n\nSELECT m.Name, L2Distance(m.Description_embedding, ref_vec_0) AS distance\nFROM Medication m\nJOIN Prescribes p ON m.Code = p.Medication\nJOIN Physician ph ON p.Physician = ph.EmployeeID\nWHERE  ph.Position = 'Specialist'\nORDER BY distance\nLIMIT 3;",
        "integration_level": 5.0
    },
    {
        "db_id": "perpetrator",
        "sql": "SELECT Perpetrator_ID\nFROM perpetrator\nWHERE Location_embedding MATCH lembed(all-MiniLM-L6-v2, \"Stadium: 123 Main St, Boston, MA. Capacity: 50,000. Home team: Patriots\")\nAND k = 1;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 1,
        "sql_complexity": "Simple",
        "question_style": "Colloquial",
        "sql_explanation": "The SQL query is designed to retrieve the `Perpetrator_ID` from the `perpetrator` table. It utilizes a vector search to find the most relevant perpetrator based on a specified location description, \"Stadium: 123 Main St, Boston, MA. Capacity: 50,000. Home team: Patriots.\" This search is conducted using the `sqlite-lembed` extension, which leverages embeddings to match the description with stored embeddings in the `Location_embedding` column. The query specifically looks for the top single match (`k = 1`), indicating that it aims to find the perpetrator most closely associated with the given stadium location.",
        "question": "Hey there! Could you find me the ID of the perpetrator who's most connected to the stadium at 123 Main St, Boston, MA, where the Patriots play? Just the top match, please!",
        "external_knowledge": "",
        "sqlite_sql": "SELECT Perpetrator_ID\nFROM perpetrator\nWHERE Location_embedding MATCH lembed('all-MiniLM-L6-v2', \"Stadium: 123 Main St, Boston, MA. Capacity: 50,000. Home team: Patriots\")\nAND k = 1;",
        "postgresql_sql": "SELECT \"Perpetrator_ID\", \"perpetrator\".\"Location_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Stadium: 123 Main St, Boston, MA. Capacity: 50,000. Home team: Patriots') AS \"distance\"\nFROM \"perpetrator\"\nORDER BY \"distance\"\nLIMIT 1;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Stadium: 123 Main St, Boston, MA. Capacity: 50,000. Home team: Patriots') AS ref_vec_0\n\nSELECT Perpetrator_ID, L2Distance(perpetrator.Location_embedding, ref_vec_0) AS distance\nFROM perpetrator\nORDER BY distance\nLIMIT 1;",
        "integration_level": 1.0
    },
    {
        "db_id": "perpetrator",
        "sql": "SELECT Perpetrator_ID, Location, Country\nFROM perpetrator\nWHERE Location_embedding MATCH lembed(all-MiniLM-L6-v2, \"123 Main St, Springfield, IL\")\nLIMIT 1;",
        "sql_result_column_count": 3,
        "sql_result_rows_count": 1,
        "sql_complexity": "Simple",
        "question_style": "Formal",
        "sql_explanation": "The SQL query is designed to retrieve details of a perpetrator from the `perpetrator` table, focusing specifically on vector similarity matching. It selects the perpetrator's unique ID, location, and country. The query uses the `Location_embedding MATCH lembed(all-MiniLM-L6-v2, \"123 Main St, Springfield, IL\")` condition, which leverages the vector extension to find the location that is most similar to the given address \"123 Main St, Springfield, IL\". The search is conducted using the `lembed` function with the `all-MiniLM-L6-v2` model to capture semantic similarity. The result is limited to a single entry (`LIMIT 1`), ensuring only the top match is returned.",
        "question": "Identify the perpetrator whose location is most similar to \"123 Main St, Springfield, IL\" and provide their ID, location, and country.",
        "external_knowledge": "",
        "sqlite_sql": "SELECT Perpetrator_ID, Location, Country\nFROM perpetrator\nWHERE Location_embedding MATCH lembed('all-MiniLM-L6-v2', \"123 Main St, Springfield, IL\")\nLIMIT 1;",
        "postgresql_sql": "SELECT \"Perpetrator_ID\", \"Location\", \"Country\", \"perpetrator\".\"Location_embedding\" <-> lembed('all-MiniLM-L6-v2', '123 Main St, Springfield, IL') AS \"distance\"\nFROM \"perpetrator\"\nORDER BY \"distance\"\nLIMIT 1;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', '123 Main St, Springfield, IL') AS ref_vec_0\n\nSELECT Perpetrator_ID, Location, Country, L2Distance(perpetrator.Location_embedding, ref_vec_0) AS distance\nFROM perpetrator\nORDER BY distance\nLIMIT 1;",
        "integration_level": 1.0
    },
    {
        "db_id": "perpetrator",
        "sql": "WITH PerpetratorCTE AS (\n  SELECT Perpetrator_ID, Location_embedding\n  FROM perpetrator\n  WHERE Location = \"Uiryeong\"\n)\nSELECT p.Name\nFROM people p\nJOIN PerpetratorCTE cte ON p.Home_Town_embedding MATCH lembed(all-MiniLM-L6-v2, \"Los Angeles, CA\") AND p.k = 1\nORDER BY distance\nLIMIT 1;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 1,
        "sql_complexity": "Complex",
        "question_style": "Descriptive",
        "sql_explanation": "The SQL query involves a vector-based operation to find individuals related to a specific location. Initially, a common table expression (CTE) named `PerpetratorCTE` is created to select `Perpetrator_ID` and `Location_embedding` for perpetrators located in \"Uiryeong\". Then, the main query seeks to identify the name of a person whose hometown vector (`Home_Town_embedding`) is most closely related to the vector representation of \"Los Angeles, CA\". This operation uses the `lembed` function and is constrained by `k = 1`, indicating that only the single best match should be selected. The results are ordered by similarity distance in ascending order, ensuring the closest match is returned. The query ultimately retrieves the name of the person who most closely matches this condition, limited to just one result.",
        "question": "I need to know the name of the person whose hometown is most similar to Los Angeles, CA, based on vector similarity, among those associated with perpetrators located in Uiryeong. Provide only the top match.",
        "external_knowledge": "",
        "sqlite_sql": "WITH PerpetratorCTE AS (\n  SELECT Perpetrator_ID, Location_embedding\n  FROM perpetrator\n  WHERE Location = \"Uiryeong\"\n)\nSELECT p.Name\nFROM people p\nJOIN PerpetratorCTE cte ON p.Home_Town_embedding MATCH lembed('all-MiniLM-L6-v2', \"Los Angeles, CA\") AND p.k = 1\nORDER BY distance\nLIMIT 1;",
        "postgresql_sql": "WITH \"PerpetratorCTE\" AS (\n    SELECT \"Perpetrator_ID\", \"Location_embedding\"\n      FROM \"perpetrator\"\n      WHERE \"Location\" = 'Uiryeong'\n)\n\nSELECT \"p\".\"Name\", \"p\".\"Home_Town_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Los Angeles, CA') AS \"distance\"\nFROM \"people\" \"p\"\nJOIN \"PerpetratorCTE\" \"cte\" ON  1=1\nORDER BY \"distance\"\nLIMIT 1;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Los Angeles, CA') AS ref_vec_0,\n\nPerpetratorCTE AS (\n    SELECT Perpetrator_ID, Location_embedding\n      FROM perpetrator\n      WHERE Location = 'Uiryeong'\n)\n\nSELECT p.Name, L2Distance(p.Home_Town_embedding, ref_vec_0) AS distance\nFROM people p\nJOIN PerpetratorCTE cte ON 1=1\nORDER BY distance\nLIMIT 1;",
        "integration_level": 5.0
    },
    {
        "db_id": "perpetrator",
        "sql": "SELECT Perpetrator_ID\nFROM perpetrator\nWHERE Location_embedding MATCH lembed(all-MiniLM-L6-v2, \"Stadium: 123 Main St, Boston, MA. Capacity: 50,000. Home team: Patriots\")\nLIMIT 1;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 1,
        "sql_complexity": "Simple",
        "question_style": "Interrogative",
        "sql_explanation": "The SQL query is designed to retrieve the Perpetrator_ID of a perpetrator whose associated location is most related to a given text description of a stadium. The description includes specific details like the address (\"123 Main St, Boston, MA\"), capacity (\"50,000\"), and home team (\"Patriots\"). The vector search is performed using the `lembed()` function with the text processed by the 'all-MiniLM-L6-v2' model. The query limits the results to the top match, returning only one perpetrator ID.",
        "question": "Could you tell me the ID of the perpetrator linked to a location most similar to \"Stadium: 123 Main St, Boston, MA. Capacity: 50,000. Home team: Patriots\"?",
        "external_knowledge": "",
        "sqlite_sql": "SELECT Perpetrator_ID\nFROM perpetrator\nWHERE Location_embedding MATCH lembed('all-MiniLM-L6-v2', \"Stadium: 123 Main St, Boston, MA. Capacity: 50,000. Home team: Patriots\")\nLIMIT 1;",
        "postgresql_sql": "SELECT \"Perpetrator_ID\", \"perpetrator\".\"Location_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Stadium: 123 Main St, Boston, MA. Capacity: 50,000. Home team: Patriots') AS \"distance\"\nFROM \"perpetrator\"\nORDER BY \"distance\"\nLIMIT 1;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Stadium: 123 Main St, Boston, MA. Capacity: 50,000. Home team: Patriots') AS ref_vec_0\n\nSELECT Perpetrator_ID, L2Distance(perpetrator.Location_embedding, ref_vec_0) AS distance\nFROM perpetrator\nORDER BY distance\nLIMIT 1;",
        "integration_level": 1.0
    },
    {
        "db_id": "musical",
        "sql": "SELECT Musical_ID, Name\nFROM musical\nWHERE Category_embedding MATCH lembed(all-MiniLM-L6-v2, \"Best Original Score\")\nAND k = 5;",
        "sql_result_column_count": 2,
        "sql_result_rows_count": 5,
        "sql_complexity": "Simple",
        "question_style": "Imperative",
        "sql_explanation": "The SQL query is selecting the `Musical_ID` and `Name` from the `musical` table. It uses a vector search to match musicals that are semantically connected to the phrase \"Best Original Score\" by leveraging the `lembed` function with the `all-MiniLM-L6-v2` model. The query is set to retrieve the top 5 musicals based on their relevance to this phrase.",
        "question": "Please find the top 5 musicals associated with the \"Best Original Score\" and provide their IDs and names.",
        "external_knowledge": "",
        "sqlite_sql": "SELECT Musical_ID, Name\nFROM musical\nWHERE Category_embedding MATCH lembed('all-MiniLM-L6-v2', \"Best Original Score\")\nAND k = 5;",
        "postgresql_sql": "SELECT \"Musical_ID\", \"Name\", \"musical\".\"Category_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Best Original Score') AS \"distance\"\nFROM \"musical\"\nORDER BY \"distance\"\nLIMIT 5;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Best Original Score') AS ref_vec_0\n\nSELECT Musical_ID, Name, L2Distance(musical.Category_embedding, ref_vec_0) AS distance\nFROM musical\nORDER BY distance\nLIMIT 5;",
        "integration_level": 1.0
    },
    {
        "db_id": "perpetrator",
        "sql": "SELECT p.Name\nFROM perpetrator pr\nJOIN people p ON pr.People_ID = p.People_ID\nWHERE pr.Location_embedding MATCH lembed(all-MiniLM-L6-v2, \"123 Main St, Boston, MA\") AND pr.k = 5;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 5,
        "sql_complexity": "Moderate",
        "question_style": "Colloquial",
        "sql_explanation": "The SQL query selects the names of people associated with perpetrators from the database. It uses a vector search operation to find perpetrators whose location embedding is most similar to the address \"123 Main St, Boston, MA\" using a pre-trained model, `all-MiniLM-L6-v2`. The query retrieves the 5 closest matches as defined by the `k = 5` condition.",
        "question": "Hey, could you find me the top 5 people who are linked to the address \"123 Main St, Boston, MA\"? I'd like to know their names!",
        "external_knowledge": "",
        "sqlite_sql": "SELECT p.Name\nFROM perpetrator pr\nJOIN people p ON pr.People_ID = p.People_ID\nWHERE pr.Location_embedding MATCH lembed('all-MiniLM-L6-v2', \"123 Main St, Boston, MA\") AND pr.k = 5;",
        "postgresql_sql": "SELECT \"p\".\"Name\", \"pr\".\"Location_embedding\" <-> lembed('all-MiniLM-L6-v2', '123 Main St, Boston, MA') AS \"distance\"\nFROM \"perpetrator\" \"pr\"\nJOIN \"people\" \"p\" ON \"pr\".\"People_ID\" = \"p\".\"People_ID\"\nORDER BY \"distance\"\nLIMIT 5;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', '123 Main St, Boston, MA') AS ref_vec_0\n\nSELECT p.Name, L2Distance(pr.Location_embedding, ref_vec_0) AS distance\nFROM perpetrator pr\nJOIN people p ON pr.People_ID = p.People_ID\nORDER BY distance\nLIMIT 5;",
        "integration_level": 5.0
    },
    {
        "db_id": "musical",
        "sql": "SELECT m.Musical_ID, a.Name\nFROM musical m\nJOIN actor a ON m.Musical_ID = a.Musical_ID\nWHERE m.Award_embedding MATCH lembed(all-MiniLM-L6-v2, \"Grammy Award\") AND m.k = 3\nAND a.Character_embedding MATCH lembed(all-MiniLM-L6-v2, \"King Lear\") AND a.k = 2\nORDER BY m.Musical_ID, a.Actor_ID;",
        "sql_result_column_count": 2,
        "sql_result_rows_count": 0,
        "sql_complexity": "Highly Complex",
        "question_style": "Vague",
        "sql_explanation": "**\n\nThis SQL query retrieves a list of musical productions along with the names of actors who are involved in those productions. The query performs a vector similarity search using the \"lembed\" method to find musicals that are most closely associated with the concept of winning a \"Grammy Award\" and actors whose characters are most closely related to the concept of \"King Lear\". The query limits the search to the top 3 musicals and the top 2 actors per musical. The results are ordered by musical ID and actor ID.\n\n**",
        "question": "**\n\nCan you list some musicals that seem to have won a Grammy and include actors who play characters reminiscent of King Lear?\n\n**",
        "external_knowledge": "**\n\nThe SQL query uses vector similarity search, where the \"MATCH lembed\" function determines the relevance of data based on embedded semantic meaning. In this context, it evaluates how closely a musical relates to the idea of winning a \"Grammy Award\" and actors to the notion of portraying \"King Lear\". The parameter \"k=3\" for musicals and \"k=2\" for actors specifies the limit on the number of top matches to return, using approximate nearest neighbor (ANN) search which typically ranks data by decreasing Euclidean distance. Essentially, it finds and ranks the musicals and actors that best fit the described themes.\n\n**",
        "sqlite_sql": "SELECT m.Musical_ID, a.Name\nFROM musical m\nJOIN actor a ON m.Musical_ID = a.Musical_ID\nWHERE m.Award_embedding MATCH lembed('all-MiniLM-L6-v2', \"Grammy Award\") AND m.k = 3\nAND a.Character_embedding MATCH lembed('all-MiniLM-L6-v2', \"King Lear\") AND a.k = 2\nORDER BY m.Musical_ID, a.Actor_ID;",
        "postgresql_sql": "WITH\n\"m_filtered\" AS (\n    SELECT\n        *,\n        \"Award_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Grammy Award') AS \"distance\"\n    FROM \"musical\"\n\n    ORDER BY \"distance\"\n    LIMIT 3\n),\n\n\"a_filtered\" AS (\n    SELECT\n        *,\n        \"Character_embedding\" <-> lembed('all-MiniLM-L6-v2', 'King Lear') AS \"distance\"\n    FROM \"actor\"\n\n    ORDER BY \"distance\"\n    LIMIT 2\n)\n\nSELECT \"m\".\"Musical_ID\", \"a\".\"Name\"\nFROM \"m_filtered\" AS \"m\"\nJOIN \"a_filtered\" AS \"a\" ON \"m\".\"Musical_ID\" = \"a\".\"Musical_ID\"\nORDER BY \"m\".\"Musical_ID\", \"a\".\"Actor_ID\";",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Grammy Award') AS ref_vec_0,\n    lembed('all-MiniLM-L6-v2', 'King Lear') AS ref_vec_1,\n\nm_filtered AS (\n    SELECT\n        *,\n        L2Distance(Award_embedding, ref_vec_0) AS distance\n    FROM musical\n\n    ORDER BY distance\n    LIMIT 3\n),\n\na_filtered AS (\n    SELECT\n        *,\n        L2Distance(Character_embedding, ref_vec_1) AS distance\n    FROM actor\n\n    ORDER BY distance\n    LIMIT 2\n)\n\nSELECT m.Musical_ID, a.Name\nFROM m_filtered AS m\nJOIN a_filtered AS a ON m.Musical_ID = a.Musical_ID\nORDER BY m.Musical_ID, a.Actor_ID;",
        "integration_level": 9.0
    },
    {
        "db_id": "musical",
        "sql": "SELECT a.Name\nFROM actor a\nJOIN musical m ON a.Musical_ID = m.Musical_ID\nWHERE m.Category_embedding MATCH lembed(all-MiniLM-L6-v2, \"Outstanding Musical Composition\") AND m.k = 5;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 8,
        "sql_complexity": "Moderate",
        "question_style": "Colloquial",
        "sql_explanation": "The SQL query is selecting the names of actors (`actor.Name`) who participated in a musical category that is deemed to have \"Outstanding Musical Composition\". The query achieves this by performing a vector similarity search on the `musical.Category_embedding` column, using the `lembed` function with the model 'all-MiniLM-L6-v2' and the phrase \"Outstanding Musical Composition\". It specifies finding the top 5 matching musicals (`m.k = 5`). The actors are identified through a join operation between the `actor` and `musical` tables based on their `Musical_ID`.",
        "question": "Hey! Can you tell me the names of the 5 actors who starred in musicals that are considered top-notch in musical composition? That'd be awesome!",
        "external_knowledge": "",
        "sqlite_sql": "SELECT a.Name\nFROM actor a\nJOIN musical m ON a.Musical_ID = m.Musical_ID\nWHERE m.Category_embedding MATCH lembed('all-MiniLM-L6-v2', \"Outstanding Musical Composition\") AND m.k = 5;",
        "postgresql_sql": "SELECT \"a\".\"Name\", \"m\".\"Category_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Outstanding Musical Composition') AS \"distance\"\nFROM \"actor\" \"a\"\nJOIN \"musical\" \"m\" ON \"a\".\"Musical_ID\" = \"m\".\"Musical_ID\"\nORDER BY \"distance\"\nLIMIT 5;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Outstanding Musical Composition') AS ref_vec_0\n\nSELECT a.Name, L2Distance(m.Category_embedding, ref_vec_0) AS distance\nFROM actor a\nJOIN musical m ON a.Musical_ID = m.Musical_ID\nORDER BY distance\nLIMIT 5;",
        "integration_level": 5.0
    },
    {
        "db_id": "musical",
        "sql": "SELECT m.Name\nFROM musical m\nJOIN actor a ON m.Musical_ID = a.Musical_ID\nWHERE m.Category_embedding MATCH lembed(all-MiniLM-L6-v2, \"Best Musical of the Year\") AND m.k = 3;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 4,
        "sql_complexity": "Moderate",
        "question_style": "Interrogative",
        "sql_explanation": "The SQL query retrieves the names of musicals that are classified as among the top three related to the phrase \"Best Musical of the Year\" based on their category embedding. It involves a vector search operation using the `lembed` function to match the `Category_embedding` of musicals, which evaluates semantic similarity to the concept of \"Best Musical of the Year.\" This operation is constrained by selecting only the top 3 matches (`m.k = 3`). Additionally, the query joins the `musical` and `actor` tables based on the `Musical_ID` to ensure that the musicals returned have actors associated with them.",
        "question": "Could you tell me the names of the top 3 musicals associated with actors that are recognized as the best musicals of the year?",
        "external_knowledge": "",
        "sqlite_sql": "SELECT m.Name\nFROM musical m\nJOIN actor a ON m.Musical_ID = a.Musical_ID\nWHERE m.Category_embedding MATCH lembed('all-MiniLM-L6-v2', \"Best Musical of the Year\") AND m.k = 3;",
        "postgresql_sql": "SELECT \"m\".\"Name\", \"m\".\"Category_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Best Musical of the Year') AS \"distance\"\nFROM \"musical\" \"m\"\nJOIN \"actor\" \"a\" ON \"m\".\"Musical_ID\" = \"a\".\"Musical_ID\"\nORDER BY \"distance\"\nLIMIT 3;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Best Musical of the Year') AS ref_vec_0\n\nSELECT m.Name, L2Distance(m.Category_embedding, ref_vec_0) AS distance\nFROM musical m\nJOIN actor a ON m.Musical_ID = a.Musical_ID\nORDER BY distance\nLIMIT 3;",
        "integration_level": 5.0
    },
    {
        "db_id": "hospital_1",
        "sql": "WITH SimilarMedications AS (\n  SELECT m.Code, m.Name, m.Brand, m.distance\n  FROM Medication m\n  WHERE m.Description_embedding MATCH lembed(all-MiniLM-L6-v2, \"Effective pain relief medication\") \n  AND m.k = 5\n  ORDER BY m.distance\n),\nPhysicianPrescriptions AS (\n  SELECT p.Name, COUNT(*) as PrescriptionCount\n  FROM Prescribes pr\n  JOIN Physician p ON pr.Physician = p.EmployeeID\n  WHERE pr.Medication IN (SELECT Code FROM SimilarMedications)\n  GROUP BY p.Name\n  ORDER BY PrescriptionCount DESC\n)\nSELECT Name\nFROM PhysicianPrescriptions\nLIMIT 1;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 1,
        "sql_complexity": "Complex",
        "question_style": "Formal",
        "sql_explanation": "The SQL query aims to identify the physician with the highest number of prescriptions for medications that are similar to an \"effective pain relief medication.\" It involves several steps: \n\n1. **Vector Search for Medications**: \n   - The query first creates a common table expression (CTE) named `SimilarMedications` by selecting medications whose description embeddings match closely with the vector embedding of the phrase \"Effective pain relief medication\" using the `lembed` function with the model `all-MiniLM-L6-v2`. It retrieves the top 5 medications ordered by similarity (distance).\n\n2. **Count Prescriptions by Physicians**: \n   - Another CTE, `PhysicianPrescriptions`, counts the number of prescriptions each physician has made for the medications in `SimilarMedications`. It joins the `Prescribes` table with the `Physician` table and groups the results by physician name, sorted in descending order by prescription count.\n\n3. **Select Top Physician**: \n   - Finally, the main query selects the name of the physician who has the highest prescription count for the similar medications, limiting the result to only one physician.",
        "question": "Identify the physician who has prescribed the most medications that are considered top 5 for effective pain relief, based on similarity to the concept of pain relief, and return their name.",
        "external_knowledge": "",
        "sqlite_sql": "WITH SimilarMedications AS (\n  SELECT m.Code, m.Name, m.Brand, m.distance\n  FROM Medication m\n  WHERE m.Description_embedding MATCH lembed('all-MiniLM-L6-v2', \"Effective pain relief medication\") \n  AND m.k = 5\n  ORDER BY m.distance\n),\nPhysicianPrescriptions AS (\n  SELECT p.Name, COUNT(*) as PrescriptionCount\n  FROM Prescribes pr\n  JOIN Physician p ON pr.Physician = p.EmployeeID\n  WHERE pr.Medication IN (SELECT Code FROM SimilarMedications)\n  GROUP BY p.Name\n  ORDER BY PrescriptionCount DESC\n)\nSELECT Name\nFROM PhysicianPrescriptions\nLIMIT 1;",
        "postgresql_sql": "WITH \"SimilarMedications\" AS (\n    SELECT \"m\".\"Code\", \"m\".\"Name\", \"m\".\"Brand\", \"m\".\"Description_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Effective pain relief medication') AS \"distance\"\n      FROM \"Medication\" \"m\"\n    ORDER BY \"distance\"\n    LIMIT 5\n),\n\n\"PhysicianPrescriptions\" AS (\n    SELECT \"p\".\"Name\", COUNT(*) as \"PrescriptionCount\"\n      FROM \"Prescribes\" \"pr\"\n      JOIN \"Physician\" \"p\" ON \"pr\".\"Physician\" = \"p\".\"EmployeeID\"\n      WHERE \"pr\".\"Medication\" IN (SELECT \"Code\" FROM \"SimilarMedications\")\n      GROUP BY \"p\".\"Name\"\n      ORDER BY \"PrescriptionCount\" DESC\n)\n\nSELECT \"Name\"\nFROM \"PhysicianPrescriptions\"\nLIMIT 1;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Effective pain relief medication') AS ref_vec_0,\n\nSimilarMedications AS (\n    SELECT m.Code, m.Name, m.Brand, L2Distance(m.Description_embedding, ref_vec_0) AS distance\n      FROM Medication m\n    ORDER BY distance\n    LIMIT 5\n),\n\nPhysicianPrescriptions AS (\n    SELECT p.Name, COUNT(*) as PrescriptionCount\n      FROM Prescribes pr\n      JOIN Physician p ON pr.Physician = p.EmployeeID\n      WHERE pr.Medication IN (SELECT Code FROM SimilarMedications)\n      GROUP BY p.Name\n      ORDER BY PrescriptionCount DESC\n)\n\nSELECT Name\nFROM PhysicianPrescriptions\nLIMIT 1;",
        "integration_level": 9.0
    },
    {
        "db_id": "farm",
        "sql": "WITH RelevantCompetitions AS (\n  SELECT fc.Competition_ID, fc.Host_city_ID, fc.distance\n  FROM farm_competition fc\n  WHERE fc.Theme_embedding MATCH lembed(all-MiniLM-L6-v2, \"Innovation in Animal Agriculture\") AND fc.k = 3\n  ORDER BY fc.distance\n),\nHostCityInfo AS (\n  SELECT c.Official_Name\n  FROM city c\n  JOIN RelevantCompetitions rc ON c.City_ID = rc.Host_city_ID\n  WHERE c.Status = 'Active'\n  ORDER BY rc.distance\n)\nSELECT Official_Name\nFROM HostCityInfo\nLIMIT 1;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 0,
        "sql_complexity": "Highly Complex",
        "question_style": "Vague",
        "sql_explanation": "The SQL query aims to identify the official name of an active host city for a farm competition that is most associated with the theme \"Innovation in Animal Agriculture.\" It uses two common table expressions (CTEs): `RelevantCompetitions` and `HostCityInfo`.\n\n1. **RelevantCompetitions CTE**: This subquery selects competitions from the `farm_competition` table where the theme embedding matches the phrase \"Innovation in Animal Agriculture,\" utilizing a vector search with the `MATCH` operator. The query retrieves the top 3 competitions based on their similarity to the theme using the `lembed` extension, then orders them by distance (similarity).\n\n2. **HostCityInfo CTE**: This subquery retrieves the official names of cities from the `city` table that are active. It joins with the `RelevantCompetitions` CTE on the host city ID and orders the cities by their distance from the theme.\n\nFinally, the main query selects the official name of the city that is closest to the theme \"Innovation in Animal Agriculture\" from this list and limits the results to one city only.",
        "question": "Which active city stands out as a host for farm competitions related to innovative practices in animal agriculture?",
        "external_knowledge": "- The `MATCH` operator is used for approximate nearest neighbor (ANN) search, which identifies the most similar items based on vector embeddings.\n- The `k=3` specifies that the query should return the top 3 most similar competitions.\n- The similarity is measured using Euclidean distance, with smaller distances indicating higher similarity.\n- The query leverages vector embeddings to semantically match the competition themes with the notion of \"Innovation in Animal Agriculture.\"\n- The extension `sqlite-lembed` facilitates the handling and querying of vector embeddings in SQLite databases, providing a mechanism to perform semantic searches.",
        "sqlite_sql": "WITH RelevantCompetitions AS (\n  SELECT fc.Competition_ID, fc.Host_city_ID, fc.distance\n  FROM farm_competition fc\n  WHERE fc.Theme_embedding MATCH lembed('all-MiniLM-L6-v2', \"Innovation in Animal Agriculture\") AND fc.k = 3\n  ORDER BY fc.distance\n),\nHostCityInfo AS (\n  SELECT c.Official_Name\n  FROM city c\n  JOIN RelevantCompetitions rc ON c.City_ID = rc.Host_city_ID\n  WHERE c.Status = 'Active'\n  ORDER BY rc.distance\n)\nSELECT Official_Name\nFROM HostCityInfo\nLIMIT 1;",
        "postgresql_sql": "WITH \"RelevantCompetitions\" AS (\n    SELECT \"fc\".\"Competition_ID\", \"fc\".\"Host_city_ID\", \"fc\".\"Theme_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Innovation in Animal Agriculture') AS \"distance\"\n      FROM \"farm_competition\" \"fc\"\n    ORDER BY \"distance\"\n    LIMIT 3\n),\n\n\"HostCityInfo\" AS (\n    SELECT \"c\".\"Official_Name\"\n      FROM \"city\" \"c\"\n      JOIN \"RelevantCompetitions\" \"rc\" ON \"c\".\"City_ID\" = \"rc\".\"Host_city_ID\"\n      WHERE \"c\".\"Status\" = 'Active'\n      ORDER BY \"rc\".\"distance\"\n)\n\nSELECT \"Official_Name\"\nFROM \"HostCityInfo\"\nLIMIT 1;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Innovation in Animal Agriculture') AS ref_vec_0,\n\nRelevantCompetitions AS (\n    SELECT fc.Competition_ID, fc.Host_city_ID, L2Distance(fc.Theme_embedding, ref_vec_0) AS distance\n      FROM farm_competition fc\n    ORDER BY distance\n    LIMIT 3\n),\n\nHostCityInfo AS (\n    SELECT c.Official_Name\n      FROM city c\n      JOIN RelevantCompetitions rc ON c.City_ID = rc.Host_city_ID\n      WHERE c.Status = 'Active'\n      ORDER BY rc.distance\n)\n\nSELECT Official_Name\nFROM HostCityInfo\nLIMIT 1;",
        "integration_level": 3.0
    },
    {
        "db_id": "farm",
        "sql": "SELECT fc.Theme, c.Official_Name, distance\nFROM farm_competition fc\nJOIN city c ON fc.Host_city_ID = c.City_ID\nWHERE fc.Theme_embedding MATCH lembed(all-MiniLM-L6-v2, \"Agricultural Innovations in Modern Farming\") AND fc.k = 5\nAND c.Area_km_2 > 500.0\nORDER BY distance LIMIT 5;",
        "sql_result_column_count": 3,
        "sql_result_rows_count": 0,
        "sql_complexity": "Moderate",
        "question_style": "Interrogative",
        "sql_explanation": "The provided SQL query aims to find specific details about farm competitions with themes closely related to \"Agricultural Innovations in Modern Farming.\" It uses vector search to determine the similarity by matching the `Theme_embedding` of each farm competition against the embedding of \"Agricultural Innovations in Modern Farming\" using the `lembed` function. The query is set to return the top 5 (`k = 5`) farm competitions based on this similarity. Additionally, it filters the cities to include only those with an area greater than 500 square kilometers. The results are ordered by the similarity distance (from most to least similar), and the query limits the output to the top 5 matches. The selected columns include the competition theme, the official city name, and the distance metric indicating similarity.",
        "question": "Could you show me the top 5 farm competition themes related to \"Agricultural Innovations in Modern Farming,\" along with the names of the host cities that have an area larger than 500 square kilometers?",
        "external_knowledge": "",
        "sqlite_sql": "SELECT fc.Theme, c.Official_Name, distance\nFROM farm_competition fc\nJOIN city c ON fc.Host_city_ID = c.City_ID\nWHERE fc.Theme_embedding MATCH lembed('all-MiniLM-L6-v2', \"Agricultural Innovations in Modern Farming\") AND fc.k = 5\nAND c.Area_km_2 > 500.0\nORDER BY distance LIMIT 5;",
        "postgresql_sql": "SELECT \"fc\".\"Theme\", \"c\".\"Official_Name\", \"fc\".\"Theme_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Agricultural Innovations in Modern Farming') AS \"distance\"\nFROM \"farm_competition\" \"fc\"\nJOIN \"city\" \"c\" ON \"fc\".\"Host_city_ID\" = \"c\".\"City_ID\"\nWHERE   \"c\".\"Area_km_2\" > 500.0\nORDER BY \"distance\"\nLIMIT 5;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Agricultural Innovations in Modern Farming') AS ref_vec_0\n\nSELECT fc.Theme, c.Official_Name, L2Distance(fc.Theme_embedding, ref_vec_0) AS distance\nFROM farm_competition fc\nJOIN city c ON fc.Host_city_ID = c.City_ID\nWHERE  c.Area_km_2 > 500.0\nORDER BY distance\nLIMIT 5;",
        "integration_level": 5.0
    },
    {
        "db_id": "farm",
        "sql": "SELECT fc.Theme\nFROM farm_competition fc\nJOIN city c ON fc.Host_city_ID = c.City_ID\nWHERE fc.Theme_embedding MATCH lembed(all-MiniLM-L6-v2, \"Agricultural Innovation\") AND fc.k = 5;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 5,
        "sql_complexity": "Moderate",
        "question_style": "Metaphorical",
        "sql_explanation": "This SQL query accesses the `farm_competition` table and retrieves the `Theme` of competitions hosted in various cities. It uses a vector search to identify themes that most closely align with the concept of \"Agricultural Innovation.\" The `MATCH` operator utilizes the `lembed` function with the `all-MiniLM-L6-v2` model to execute an approximate nearest neighbor search. The query is designed to return the top 5 themes that are most representative of agricultural innovation, based on their vector embeddings.",
        "question": "Can you unveil the top 5 themes that sparkle with agricultural innovation, celebrated in city-hosted farm competitions?",
        "external_knowledge": "The `MATCH` operator combined with `lembed()` is used for vector similarity searches in SQLite, specifically when using the `sqlite-vec` extension. Here, it identifies themes conceptually closest to \"Agricultural Innovation.\" The desired number of results is specified by `k=5`, meaning the search will return the top 5 themes. This process compares vector embeddings using Euclidean distance, where lower distances indicate greater similarity. The search is based on the semantic understanding of \"Agricultural Innovation,\" which encompasses advancements in farming techniques, sustainable practices, and new agricultural technologies.",
        "sqlite_sql": "SELECT fc.Theme\nFROM farm_competition fc\nJOIN city c ON fc.Host_city_ID = c.City_ID\nWHERE fc.Theme_embedding MATCH lembed('all-MiniLM-L6-v2', \"Agricultural Innovation\") AND fc.k = 5;",
        "postgresql_sql": "SELECT \"fc\".\"Theme\", \"fc\".\"Theme_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Agricultural Innovation') AS \"distance\"\nFROM \"farm_competition\" \"fc\"\nJOIN \"city\" \"c\" ON \"fc\".\"Host_city_ID\" = \"c\".\"City_ID\"\nORDER BY \"distance\"\nLIMIT 5;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Agricultural Innovation') AS ref_vec_0\n\nSELECT fc.Theme, L2Distance(fc.Theme_embedding, ref_vec_0) AS distance\nFROM farm_competition fc\nJOIN city c ON fc.Host_city_ID = c.City_ID\nORDER BY distance\nLIMIT 5;",
        "integration_level": 5.0
    },
    {
        "db_id": "farm",
        "sql": "WITH RelevantCompetitions AS (\n  SELECT Competition_ID, Host_city_ID, distance\n  FROM farm_competition\n  WHERE Theme_embedding MATCH lembed(all-MiniLM-L6-v2, \"Harvest Celebration\")\n  AND k = 5\n)\n\nSELECT c.Official_Name\nFROM RelevantCompetitions rc\nJOIN city c ON rc.Host_city_ID = c.City_ID\nWHERE c.Status = 'active'\nORDER BY rc.distance\nLIMIT 1;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 0,
        "sql_complexity": "Complex",
        "question_style": "Descriptive",
        "sql_explanation": "The SQL query involves two primary operations:\n\n1. **Vector Search Operation**: The first part of the query creates a temporary view called `RelevantCompetitions`. It selects competitions from the `farm_competition` table where the theme of the competition, represented as a vector embedding (`Theme_embedding`), is closely related to the concept of \"Harvest Celebration.\" This is done using the `lembed()` function with the model `all-MiniLM-L6-v2`. The search is limited to the top 5 matches (`k = 5`), sorting them by their distance metric which represents similarity.\n\n2. **Joining and Filtering**: The second part of the query retrieves the official name of the city from the `city` table where the competition is hosted. This is done by joining the `RelevantCompetitions` with the `city` table using `Host_city_ID` and `City_ID`. The query only considers cities with an `active` status. Finally, it orders the results by distance and limits the result to the single most closely related city, providing the official name of the city that best matches the theme requirement.",
        "question": "I am interested in finding the official name of the active city that is hosting a competition with the theme most closely related to \"Harvest Celebration.\" Please provide the name of the top single match based on this theme association.",
        "external_knowledge": "",
        "sqlite_sql": "WITH RelevantCompetitions AS (\n  SELECT Competition_ID, Host_city_ID, distance\n  FROM farm_competition\n  WHERE Theme_embedding MATCH lembed('all-MiniLM-L6-v2', \"Harvest Celebration\")\n  AND k = 5\n)\n\nSELECT c.Official_Name\nFROM RelevantCompetitions rc\nJOIN city c ON rc.Host_city_ID = c.City_ID\nWHERE c.Status = 'active'\nORDER BY rc.distance\nLIMIT 1;",
        "postgresql_sql": "WITH \"RelevantCompetitions\" AS (\n    SELECT \"Competition_ID\", \"Host_city_ID\", \"farm_competition\".\"Theme_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Harvest Celebration') AS \"distance\"\n      FROM \"farm_competition\"\n    ORDER BY \"distance\"\n    LIMIT 5\n)\n\nSELECT \"c\".\"Official_Name\"\nFROM \"RelevantCompetitions\" \"rc\"\nJOIN \"city\" \"c\" ON \"rc\".\"Host_city_ID\" = \"c\".\"City_ID\"\nWHERE \"c\".\"Status\" = 'active'\nORDER BY \"rc\".\"distance\"\nLIMIT 1;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Harvest Celebration') AS ref_vec_0,\n\nRelevantCompetitions AS (\n    SELECT Competition_ID, Host_city_ID, L2Distance(farm_competition.Theme_embedding, ref_vec_0) AS distance\n      FROM farm_competition\n    ORDER BY distance\n    LIMIT 5\n)\n\nSELECT c.Official_Name\nFROM RelevantCompetitions rc\nJOIN city c ON rc.Host_city_ID = c.City_ID\nWHERE c.Status = 'active'\nORDER BY rc.distance\nLIMIT 1;",
        "integration_level": 3.0
    },
    {
        "db_id": "farm",
        "sql": "WITH ThemeMatches AS (\n  SELECT fc.Competition_ID, fc.Host_city_ID, fc.distance\n  FROM farm_competition fc\n  WHERE fc.Theme_embedding MATCH lembed(all-MiniLM-L6-v2, \"Festival B returns!\")\n  AND fc.k = 3\n  \n  ORDER BY fc.distance\n),\nPopulationFilter AS (\n  SELECT c.City_ID\n  FROM city c\n  WHERE c.Population > 1000000\n  \n),\nTopRankedFarms AS (\n  SELECT cr.Farm_ID, cr.Rank\n  FROM competition_record cr\n  JOIN ThemeMatches tm ON cr.Competition_ID = tm.Competition_ID\n  WHERE cr.Rank = 1\n  \n),\nFinalSelection AS (\n  SELECT tm.Competition_ID, tf.Farm_ID, tf.Rank, tm.distance\n  FROM TopRankedFarms tf\n  JOIN ThemeMatches tm ON tf.Farm_ID = tm.Competition_ID\n  WHERE tm.Host_city_ID IN (SELECT City_ID FROM PopulationFilter)\n  \n)\n\nSELECT fs.Farm_ID\nFROM FinalSelection fs\nORDER BY fs.distance\nLIMIT 1;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 0,
        "sql_complexity": "Highly Complex",
        "question_style": "Formal",
        "sql_explanation": "The SQL query seeks to identify farms that participate in competitions with themes closely matching \"Festival B returns!\" using vector embeddings. First, it finds the top 3 competitions with themes most closely related to \"Festival B returns!\" by leveraging the `lembed` function with `all-MiniLM-L6-v2` model and orders them by `distance`. \n\nNext, it filters cities with a population greater than 1 million. Only competitions hosted in such cities are considered.\n\nAmong these competitions, the query selects farms ranked first in their respective competitions. Finally, it selects one farm from these top-ranked farms, which has the smallest similarity distance, which indicates the farm's competition is most closely related to the thematic match of \"Festival B returns!\".",
        "question": "Identify the farm that participated in the competition most closely associated with the theme \"Festival B returns!\", limited to competitions hosted in cities with populations exceeding one million. Ensure this farm is ranked first in its competition and selected based on the closest thematic match.",
        "external_knowledge": "",
        "sqlite_sql": "WITH ThemeMatches AS (\n  SELECT fc.Competition_ID, fc.Host_city_ID, fc.distance\n  FROM farm_competition fc\n  WHERE fc.Theme_embedding MATCH lembed('all-MiniLM-L6-v2', \"Festival B returns!\")\n  AND fc.k = 3\n  \n  ORDER BY fc.distance\n),\nPopulationFilter AS (\n  SELECT c.City_ID\n  FROM city c\n  WHERE c.Population > 1000000\n  \n),\nTopRankedFarms AS (\n  SELECT cr.Farm_ID, cr.Rank\n  FROM competition_record cr\n  JOIN ThemeMatches tm ON cr.Competition_ID = tm.Competition_ID\n  WHERE cr.Rank = 1\n  \n),\nFinalSelection AS (\n  SELECT tm.Competition_ID, tf.Farm_ID, tf.Rank, tm.distance\n  FROM TopRankedFarms tf\n  JOIN ThemeMatches tm ON tf.Farm_ID = tm.Competition_ID\n  WHERE tm.Host_city_ID IN (SELECT City_ID FROM PopulationFilter)\n  \n)\n\nSELECT fs.Farm_ID\nFROM FinalSelection fs\nORDER BY fs.distance\nLIMIT 1;",
        "postgresql_sql": "WITH \"ThemeMatches\" AS (\n    SELECT \"fc\".\"Competition_ID\", \"fc\".\"Host_city_ID\", \"fc\".\"Theme_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Festival B returns!') AS \"distance\"\n      FROM \"farm_competition\" \"fc\"\n    ORDER BY \"distance\"\n    LIMIT 3\n),\n\n\"PopulationFilter\" AS (\n    SELECT \"c\".\"City_ID\"\n      FROM \"city\" \"c\"\n      WHERE \"c\".\"Population\" > 1000000\n),\n\n\"TopRankedFarms\" AS (\n    SELECT \"cr\".\"Farm_ID\", \"cr\".\"Rank\"\n      FROM \"competition_record\" \"cr\"\n      JOIN \"ThemeMatches\" \"tm\" ON \"cr\".\"Competition_ID\" = \"tm\".\"Competition_ID\"\n      WHERE \"cr\".\"Rank\" = 1\n),\n\n\"FinalSelection\" AS (\n    SELECT \"tm\".\"Competition_ID\", \"tf\".\"Farm_ID\", \"tf\".\"Rank\", \"tm\".\"distance\"\n      FROM \"TopRankedFarms\" \"tf\"\n      JOIN \"ThemeMatches\" \"tm\" ON \"tf\".\"Farm_ID\" = \"tm\".\"Competition_ID\"\n      WHERE \"tm\".\"Host_city_ID\" IN (SELECT \"City_ID\" FROM \"PopulationFilter\")\n)\n\nSELECT \"fs\".\"Farm_ID\"\nFROM \"FinalSelection\" \"fs\"\nORDER BY \"fs\".\"distance\"\nLIMIT 1;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Festival B returns!') AS ref_vec_0,\n\nThemeMatches AS (\n    SELECT fc.Competition_ID, fc.Host_city_ID, L2Distance(fc.Theme_embedding, ref_vec_0) AS distance\n      FROM farm_competition fc\n    ORDER BY distance\n    LIMIT 3\n),\n\nPopulationFilter AS (\n    SELECT c.City_ID\n      FROM city c\n      WHERE c.Population > 1000000\n),\n\nTopRankedFarms AS (\n    SELECT cr.Farm_ID, cr.Rank\n      FROM competition_record cr\n      JOIN ThemeMatches tm ON cr.Competition_ID = tm.Competition_ID\n      WHERE cr.Rank = 1\n),\n\nFinalSelection AS (\n    SELECT tm.Competition_ID, tf.Farm_ID, tf.Rank, tm.distance\n      FROM TopRankedFarms tf\n      JOIN ThemeMatches tm ON tf.Farm_ID = tm.Competition_ID\n      WHERE tm.Host_city_ID IN (SELECT City_ID FROM PopulationFilter)\n)\n\nSELECT fs.Farm_ID\nFROM FinalSelection fs\nORDER BY fs.distance\nLIMIT 1;",
        "integration_level": 3.0
    },
    {
        "db_id": "farm",
        "sql": "SELECT Competition_ID, Year\nFROM farm_competition\nWHERE Theme_embedding MATCH lembed(all-MiniLM-L6-v2, \"Festival and community events\")\nAND k = 3;",
        "sql_result_column_count": 2,
        "sql_result_rows_count": 3,
        "sql_complexity": "Simple",
        "question_style": "Imperative",
        "sql_explanation": "The SQL query retrieves the `Competition_ID` and `Year` of competitions from the `farm_competition` table. It uses a vector search operation to find competitions whose theme is closely related to the concept of \"Festival and community events.\" This vector similarity search is performed using the `MATCH` function with `lembed(all-MiniLM-L6-v2, \"Festival and community events\")`. The query is limited to return the top 3 competitions that best match this theme, as specified by the condition `AND k = 3`.",
        "question": "Could you please find the top three competitions that are themed around festivals and community events? I need to know their IDs and the years they took place!",
        "external_knowledge": "",
        "sqlite_sql": "SELECT Competition_ID, Year\nFROM farm_competition\nWHERE Theme_embedding MATCH lembed('all-MiniLM-L6-v2', \"Festival and community events\")\nAND k = 3;",
        "postgresql_sql": "SELECT \"Competition_ID\", \"Year\", \"farm_competition\".\"Theme_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Festival and community events') AS \"distance\"\nFROM \"farm_competition\"\nORDER BY \"distance\"\nLIMIT 3;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Festival and community events') AS ref_vec_0\n\nSELECT Competition_ID, Year, L2Distance(farm_competition.Theme_embedding, ref_vec_0) AS distance\nFROM farm_competition\nORDER BY distance\nLIMIT 3;",
        "integration_level": 2.0
    },
    {
        "db_id": "farm",
        "sql": "SELECT fc.Competition_ID\nFROM farm_competition fc\nJOIN city c ON fc.Host_city_ID = c.City_ID\nWHERE fc.Theme_embedding MATCH lembed(all-MiniLM-L6-v2, \"Agricultural Innovations\")\nAND c.Official_Name = 'Springfield'\nAND fc.k = 5;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 0,
        "sql_complexity": "Moderate",
        "question_style": "Vague",
        "sql_explanation": "This SQL query is designed to retrieve the 'Competition_ID' from the 'farm_competition' table for competitions that are hosted in the city of 'Springfield' and are themed around 'Agricultural Innovations'. The query utilizes a vector search operation with the 'MATCH' operator to find the top 5 competitions whose themes are most related to 'Agricultural Innovations', as determined by the vector embedding model 'all-MiniLM-L6-v2'. The condition `AND fc.k = 5` specifies that only the top 5 most relevant competitions should be selected based on their theme similarity.",
        "question": "Which five competitions held in Springfield are notable for their focus on agricultural innovations?",
        "external_knowledge": "In vector searches, the 'MATCH' operator is used to perform an approximate nearest neighbor (ANN) search. This allows for finding items that are most similar to a given query based on vector embeddings. The `lembed('all-MiniLM-L6-v2', \"Agricultural Innovations\")` function call generates an embedding for the concept of 'Agricultural Innovations', which is then used to find similar themes in the competition data. The `k = 5` condition limits the results to the five most relevant competitions. The similarity is determined by the Euclidean distance between vectors, where smaller distances indicate greater similarity.",
        "sqlite_sql": "SELECT fc.Competition_ID\nFROM farm_competition fc\nJOIN city c ON fc.Host_city_ID = c.City_ID\nWHERE fc.Theme_embedding MATCH lembed('all-MiniLM-L6-v2', \"Agricultural Innovations\")\nAND c.Official_Name = 'Springfield'\nAND fc.k = 5;",
        "postgresql_sql": "SELECT \"fc\".\"Competition_ID\", \"fc\".\"Theme_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Agricultural Innovations') AS \"distance\"\nFROM \"farm_competition\" \"fc\"\nJOIN \"city\" \"c\" ON \"fc\".\"Host_city_ID\" = \"c\".\"City_ID\"\nWHERE  \"c\".\"Official_Name\" = 'Springfield'\nORDER BY \"distance\"\nLIMIT 5;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Agricultural Innovations') AS ref_vec_0\n\nSELECT fc.Competition_ID, L2Distance(fc.Theme_embedding, ref_vec_0) AS distance\nFROM farm_competition fc\nJOIN city c ON fc.Host_city_ID = c.City_ID\nWHERE  c.Official_Name = 'Springfield'\nORDER BY distance\nLIMIT 5;",
        "integration_level": 5.0
    },
    {
        "db_id": "farm",
        "sql": "SELECT Competition_ID\nFROM farm_competition\nWHERE Theme_embedding MATCH lembed(all-MiniLM-L6-v2, \"Agricultural Innovation Summit\")\nLIMIT 1;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 1,
        "sql_complexity": "Simple",
        "question_style": "Concise",
        "sql_explanation": "The SQL query is designed to find the unique Competition_ID from the `farm_competition` table where the theme of the competition is matched using a vector search. Specifically, it uses the `lembed` function to find competitions whose themes are most closely related to \"Agricultural Innovation Summit\" based on semantic similarity. The search leverages the `all-MiniLM-L6-v2` model for embedding, and it limits the results to the top 1 most relevant competition.",
        "question": "Find the top competition that is most relevant to the \"Agricultural Innovation Summit\".",
        "external_knowledge": "",
        "sqlite_sql": "SELECT Competition_ID\nFROM farm_competition\nWHERE Theme_embedding MATCH lembed('all-MiniLM-L6-v2', \"Agricultural Innovation Summit\")\nLIMIT 1;",
        "postgresql_sql": "SELECT \"Competition_ID\", \"farm_competition\".\"Theme_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Agricultural Innovation Summit') AS \"distance\"\nFROM \"farm_competition\"\nORDER BY \"distance\"\nLIMIT 1;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Agricultural Innovation Summit') AS ref_vec_0\n\nSELECT Competition_ID, L2Distance(farm_competition.Theme_embedding, ref_vec_0) AS distance\nFROM farm_competition\nORDER BY distance\nLIMIT 1;",
        "integration_level": 1.0
    },
    {
        "db_id": "game_injury",
        "sql": "SELECT g.Date\nFROM game g\nJOIN injury_accident ia ON g.id = ia.game_id\nWHERE ia.Injury_embedding MATCH lembed(all-MiniLM-L6-v2, \"Knee injury during a match\") AND ia.k = 3;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 3,
        "sql_complexity": "Moderate",
        "question_style": "Descriptive",
        "sql_explanation": "The SQL query aims to retrieve the dates of games that are associated with particular injuries or accidents described in the database. Specifically, it performs a vector similarity search using the `Injury_embedding` column to find game instances where the injury description is most similar to \"Knee injury during a match\". This search is done using the `MATCH lembed(all-MiniLM-L6-v2, \"Knee injury during a match\")` function, which compares the injury descriptions stored as vector embeddings to the given phrase. The query specifies that it should return the top 3 matches (`ia.k = 3`) based on this similarity search. The information is fetched by joining the `game` table with the `injury_accident` table using the `game_id`.",
        "question": "I need the dates of the top 3 games where a knee injury occurred during the match. Could you find these games based on the similarity of injury descriptions?",
        "external_knowledge": "",
        "sqlite_sql": "SELECT g.Date\nFROM game g\nJOIN injury_accident ia ON g.id = ia.game_id\nWHERE ia.Injury_embedding MATCH lembed('all-MiniLM-L6-v2', \"Knee injury during a match\") AND ia.k = 3;",
        "postgresql_sql": "SELECT \"g\".\"Date\", \"ia\".\"Injury_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Knee injury during a match') AS \"distance\"\nFROM \"game\" \"g\"\nJOIN \"injury_accident\" \"ia\" ON \"g\".\"id\" = \"ia\".\"game_id\"\nORDER BY \"distance\"\nLIMIT 3;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Knee injury during a match') AS ref_vec_0\n\nSELECT g.Date, L2Distance(ia.Injury_embedding, ref_vec_0) AS distance\nFROM game g\nJOIN injury_accident ia ON g.id = ia.game_id\nORDER BY distance\nLIMIT 3;",
        "integration_level": 5.0
    },
    {
        "db_id": "game_injury",
        "sql": "SELECT id, Player\nFROM injury_accident\nWHERE Injury_embedding MATCH lembed(all-MiniLM-L6-v2, \"Ligament tear\") LIMIT 5;",
        "sql_result_column_count": 2,
        "sql_result_rows_count": 5,
        "sql_complexity": "Simple",
        "question_style": "Imperative",
        "sql_explanation": "The SQL query is designed to retrieve a list of players who are associated with injuries closely related to the concept of a \"Ligament tear.\" This is accomplished by using the `MATCH` operation with the `lembed` function, which performs a vector similarity search to find records where the `Injury_embedding` vector is similar to the vector representation of \"Ligament tear.\" The query selects the `id` and `Player` columns from the `injury_accident` table and limits the results to the top 5 most closely related entries based on their vector similarity to \"Ligament tear.\"",
        "question": "Could you please find the top 5 players who have had ligament tear injuries and give me their IDs and names?",
        "external_knowledge": "",
        "sqlite_sql": "SELECT id, Player\nFROM injury_accident\nWHERE Injury_embedding MATCH lembed('all-MiniLM-L6-v2', \"Ligament tear\") LIMIT 5;",
        "postgresql_sql": "SELECT \"id\", \"Player\", \"injury_accident\".\"Injury_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Ligament tear') AS \"distance\"\nFROM \"injury_accident\"\nORDER BY \"distance\"\nLIMIT 5;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Ligament tear') AS ref_vec_0\n\nSELECT id, Player, L2Distance(injury_accident.Injury_embedding, ref_vec_0) AS distance\nFROM injury_accident\nORDER BY distance\nLIMIT 5;",
        "integration_level": 1.0
    },
    {
        "db_id": "game_injury",
        "sql": "SELECT ia.Player\nFROM injury_accident ia\nJOIN game g ON ia.game_id = g.id\nWHERE ia.Injury_embedding MATCH lembed(all-MiniLM-L6-v2, \"Knee surgery recovery\") AND ia.k = 3;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 3,
        "sql_complexity": "Moderate",
        "question_style": "Interrogative",
        "sql_explanation": "The SQL query is designed to retrieve the names of players from the `injury_accident` table who have an injury related to \"Knee surgery recovery.\" It achieves this by performing a vector search using the `MATCH lembed(all-MiniLM-L6-v2, \"Knee surgery recovery\")` clause, which identifies the most relevant injuries associated with knee surgery recovery. The query then retrieves the top 3 results based on this vector similarity. Additionally, the query joins the `injury_accident` table with the `game` table on the `game_id` to ensure that the injuries are associated with specific games.",
        "question": "Could you tell me the names of the three players whose injuries are most related to recovering from knee surgery?",
        "external_knowledge": "",
        "sqlite_sql": "SELECT ia.Player\nFROM injury_accident ia\nJOIN game g ON ia.game_id = g.id\nWHERE ia.Injury_embedding MATCH lembed('all-MiniLM-L6-v2', \"Knee surgery recovery\") AND ia.k = 3;",
        "postgresql_sql": "SELECT \"ia\".\"Player\", \"ia\".\"Injury_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Knee surgery recovery') AS \"distance\"\nFROM \"injury_accident\" \"ia\"\nJOIN \"game\" \"g\" ON \"ia\".\"game_id\" = \"g\".\"id\"\nORDER BY \"distance\"\nLIMIT 3;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Knee surgery recovery') AS ref_vec_0\n\nSELECT ia.Player, L2Distance(ia.Injury_embedding, ref_vec_0) AS distance\nFROM injury_accident ia\nJOIN game g ON ia.game_id = g.id\nORDER BY distance\nLIMIT 3;",
        "integration_level": 5.0
    },
    {
        "db_id": "game_injury",
        "sql": "SELECT ia.Player, g.Date\nFROM injury_accident ia\nJOIN game g ON ia.game_id = g.id\nWHERE ia.Injury_embedding MATCH lembed(all-MiniLM-L6-v2, \"Knee issue\") AND ia.k = 5\nORDER BY distance\nLIMIT 5;",
        "sql_result_column_count": 2,
        "sql_result_rows_count": 5,
        "sql_complexity": "Moderate",
        "question_style": "Concise",
        "sql_explanation": "The SQL query selects the names of players and the dates of the games from two tables: `injury_accident` and `game`. The tables are joined using the `game_id`. The query filters for injuries related to knee issues using vector similarity matching with the `lembed` function. It searches for the top 5 entries (`ia.k = 5`) that match the \"Knee issue\" in the `Injury_embedding` column, which is performed using the specified embedding model `all-MiniLM-L6-v2`. The results are ordered by `distance`, indicating similarity, and are limited to the top 5 entries.",
        "question": "Who are the top 5 players with knee-related injuries, and when did they occur?",
        "external_knowledge": "",
        "sqlite_sql": "SELECT ia.Player, g.Date\nFROM injury_accident ia\nJOIN game g ON ia.game_id = g.id\nWHERE ia.Injury_embedding MATCH lembed('all-MiniLM-L6-v2', \"Knee issue\") AND ia.k = 5\nORDER BY distance\nLIMIT 5;",
        "postgresql_sql": "SELECT \"ia\".\"Player\", \"g\".\"Date\", \"ia\".\"Injury_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Knee issue') AS \"distance\"\nFROM \"injury_accident\" \"ia\"\nJOIN \"game\" \"g\" ON \"ia\".\"game_id\" = \"g\".\"id\"\nORDER BY \"distance\"\nLIMIT 5;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Knee issue') AS ref_vec_0\n\nSELECT ia.Player, g.Date, L2Distance(ia.Injury_embedding, ref_vec_0) AS distance\nFROM injury_accident ia\nJOIN game g ON ia.game_id = g.id\nORDER BY distance\nLIMIT 5;",
        "integration_level": 5.0
    },
    {
        "db_id": "game_injury",
        "sql": "WITH InjuryMatches AS (\n  SELECT \n    ia.id,\n    ia.Injury,\n    ia.game_id,\n    distance\n  FROM injury_accident ia\n  WHERE ia.Injury_embedding MATCH lembed(all-MiniLM-L6-v2, \"ACL tear\") \n  AND k = 5 \n),\nGameDetails AS (\n  SELECT \n    g.id AS game_id,\n    g.Date,\n    g.Home_team,\n    g.Away_team,\n    g.Competition,\n    im.distance\n  FROM game g\n  JOIN InjuryMatches im ON g.id = im.game_id\n),\nStadiumAnalytics AS (\n  SELECT \n    s.name,\n    s.Capacity_Percentage,\n    gd.distance\n  FROM stadium s\n  JOIN GameDetails gd ON s.id = gd.game_id\n  WHERE s.Capacity_Percentage > 75\n)\n\nSELECT \n  sa.name\nFROM StadiumAnalytics sa\nORDER BY sa.distance\nLIMIT 1;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 1,
        "sql_complexity": "Highly Complex",
        "question_style": "Colloquial",
        "sql_explanation": "The SQL query is structured in multiple steps:\n\n1. **InjuryMatches View**: It first creates a temporary view called `InjuryMatches`, which selects the `id`, `Injury`, `game_id`, and `distance` from the `injury_accident` table. This view is filtered to include only injuries that are semantically similar to \"ACL tear\" using a vector search operation with `MATCH lembed(all-MiniLM-L6-v2, \"ACL tear\")`. It limits the search to the top 5 matches (`AND k = 5`).\n\n2. **GameDetails View**: Next, it creates another temporary view called `GameDetails`, which selects the `game_id`, `Date`, `Home_team`, `Away_team`, `Competition`, and the `distance` from the `game` table. This view joins with the `InjuryMatches` view on the `game_id` to correlate games with the top matching injuries.\n\n3. **StadiumAnalytics View**: Then, it forms a view named `StadiumAnalytics` that selects the `name` and `Capacity_Percentage` from the `stadium` table, joining it with `GameDetails` on `game_id`. Only stadiums with a capacity utilization over 75% are included.\n\n4. **Final Selection**: Finally, the main query selects the `name` of the stadium from `StadiumAnalytics` and orders the results by `distance` to identify which stadium had the closest connection to the \"ACL tear\" injuries. It limits the result to just the top stadium (`LIMIT 1`).",
        "question": "Hey there! Can you find me the stadium with the highest capacity utilization that hosted a game with one of the top 5 injuries similar to an ACL tear? I need the name of that stadium, please!",
        "external_knowledge": "",
        "sqlite_sql": "WITH InjuryMatches AS (\n  SELECT \n    ia.id,\n    ia.Injury,\n    ia.game_id,\n    distance\n  FROM injury_accident ia\n  WHERE ia.Injury_embedding MATCH lembed('all-MiniLM-L6-v2', \"ACL tear\") \n  AND k = 5 \n),\nGameDetails AS (\n  SELECT \n    g.id AS game_id,\n    g.Date,\n    g.Home_team,\n    g.Away_team,\n    g.Competition,\n    im.distance\n  FROM game g\n  JOIN InjuryMatches im ON g.id = im.game_id\n),\nStadiumAnalytics AS (\n  SELECT \n    s.name,\n    s.Capacity_Percentage,\n    gd.distance\n  FROM stadium s\n  JOIN GameDetails gd ON s.id = gd.game_id\n  WHERE s.Capacity_Percentage > 75\n)\n\nSELECT \n  sa.name\nFROM StadiumAnalytics sa\nORDER BY sa.distance\nLIMIT 1;",
        "postgresql_sql": "WITH \"InjuryMatches\" AS (\n    SELECT \n        \"ia\".\"id\",\n        \"ia\".\"Injury\",\n        \"ia\".\"game_id\",\n        \"ia\".\"Injury_embedding\" <-> lembed('all-MiniLM-L6-v2', 'ACL tear') AS \"distance\"\n      FROM \"injury_accident\" \"ia\"\n    ORDER BY \"distance\"\n    LIMIT 5\n),\n\n\"GameDetails\" AS (\n    SELECT \n        \"g\".\"id\" AS \"game_id\",\n        \"g\".\"Date\",\n        \"g\".\"Home_team\",\n        \"g\".\"Away_team\",\n        \"g\".\"Competition\",\n        \"im\".\"distance\"\n      FROM \"game\" \"g\"\n      JOIN \"InjuryMatches\" \"im\" ON \"g\".\"id\" = \"im\".\"game_id\"\n),\n\n\"StadiumAnalytics\" AS (\n    SELECT \n        \"s\".\"name\",\n        \"s\".\"Capacity_Percentage\",\n        \"gd\".\"distance\"\n      FROM \"stadium\" \"s\"\n      JOIN \"GameDetails\" \"gd\" ON \"s\".\"id\" = \"gd\".\"game_id\"\n      WHERE \"s\".\"Capacity_Percentage\" > 75\n)\n\nSELECT \n  \"sa\".\"name\"\nFROM \"StadiumAnalytics\" \"sa\"\nORDER BY \"sa\".\"distance\"\nLIMIT 1;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'ACL tear') AS ref_vec_0,\n\nInjuryMatches AS (\n    SELECT \n        ia.id,\n        ia.Injury,\n        ia.game_id,\n        L2Distance(ia.Injury_embedding, ref_vec_0) AS distance\n      FROM injury_accident ia\n    ORDER BY distance\n    LIMIT 5\n),\n\nGameDetails AS (\n    SELECT \n        g.id AS game_id,\n        g.Date,\n        g.Home_team,\n        g.Away_team,\n        g.Competition,\n        im.distance\n      FROM game g\n      JOIN InjuryMatches im ON g.id = im.game_id\n),\n\nStadiumAnalytics AS (\n    SELECT \n        s.name,\n        s.Capacity_Percentage,\n        gd.distance\n      FROM stadium s\n      JOIN GameDetails gd ON s.id = gd.game_id\n      WHERE s.Capacity_Percentage > 75\n)\n\nSELECT \n  sa.name\nFROM StadiumAnalytics sa\nORDER BY sa.distance\nLIMIT 1;",
        "integration_level": 1.0
    },
    {
        "db_id": "station_weather",
        "sql": "SELECT network_name\nFROM station\nWHERE services_embedding MATCH lembed(all-MiniLM-L6-v2, \"London Overground and Midland\") \nAND k = 1;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 1,
        "sql_complexity": "Simple",
        "question_style": "Colloquial",
        "sql_explanation": "This SQL query is selecting the `network_name` from the `station` table. It is using a vector search technique to find the transportation network whose services are most closely aligned with the description \"London Overground and Midland\" using the textual embedding model `all-MiniLM-L6-v2`. The `MATCH` function helps in identifying the most similar network based on this embedding, and the condition `k = 1` specifies that we only want the single best match for this query.",
        "question": "Hey! Can you tell me which transport network is the top match for the services like \"London Overground and Midland\"? I'd love to know its name!",
        "external_knowledge": "",
        "sqlite_sql": "SELECT network_name\nFROM station\nWHERE services_embedding MATCH lembed('all-MiniLM-L6-v2', \"London Overground and Midland\") \nAND k = 1;",
        "postgresql_sql": "SELECT \"network_name\", \"station\".\"services_embedding\" <-> lembed('all-MiniLM-L6-v2', 'London Overground and Midland') AS \"distance\"\nFROM \"station\"\nORDER BY \"distance\"\nLIMIT 1;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'London Overground and Midland') AS ref_vec_0\n\nSELECT network_name, L2Distance(station.services_embedding, ref_vec_0) AS distance\nFROM station\nORDER BY distance\nLIMIT 1;",
        "integration_level": 2.0
    },
    {
        "db_id": "station_weather",
        "sql": "SELECT s.network_name\nFROM station s\nJOIN weekly_weather w ON s.id = w.station_id\nWHERE s.services_embedding MATCH lembed(all-MiniLM-L6-v2, \"London Underground and National Rail services\")\n  AND w.high_temperature > 75\n  AND k = 5;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 0,
        "sql_complexity": "Moderate",
        "question_style": "Vague",
        "sql_explanation": "The SQL query is designed to retrieve the names of transportation networks from the `station` table. It performs a join with the `weekly_weather` table, linking records based on the station ID. The query then filters these networks by using a vector-based search to find stations whose services are similar to \"London Underground and National Rail services,\" utilizing the `lembed` function with the `all-MiniLM-L6-v2` model. This search is performed using a vector similarity operation where the MATCH operator identifies approximate nearest neighbors. Additionally, the query restricts the results to stations where the high temperature recorded in the `weekly_weather` table exceeds 75 degrees. The parameter `k = 5` specifies that only the top 5 matching network names should be returned based on their vector similarity to the specified services.",
        "question": "Could you tell me the five transportation networks that operate services somewhat like the London Underground and National Rail, particularly where the weather gets really hot?",
        "external_knowledge": "The query uses a vector similarity search to find entities (transportation networks) that best match the concept of \"London Underground and National Rail services.\" This involves approximate nearest neighbor (ANN) search with the `MATCH` operator, which measures similarity based on Euclidean distance. The `lembed` function leverages the `all-MiniLM-L6-v2` model, a multilingual transformer model used for semantic similarity tasks. The parameter `k = 5` ensures that the top 5 closest matches are returned. In this context, higher similarity corresponds to shorter distances in the vector space. The reference to \"services\" implies comparing operational characteristics of networks, and \"high temperature > 75\" suggests focusing on networks in regions experiencing hot weather.",
        "sqlite_sql": "SELECT s.network_name\nFROM station s\nJOIN weekly_weather w ON s.id = w.station_id\nWHERE s.services_embedding MATCH lembed('all-MiniLM-L6-v2', \"London Underground and National Rail services\")\n  AND w.high_temperature > 75\n  AND k = 5;",
        "postgresql_sql": "SELECT \"s\".\"network_name\", \"s\".\"services_embedding\" <-> lembed('all-MiniLM-L6-v2', 'London Underground and National Rail services') AS \"distance\"\nFROM \"station\" \"s\"\nJOIN \"weekly_weather\" \"w\" ON \"s\".\"id\" = \"w\".\"station_id\"\nWHERE  \"w\".\"high_temperature\" > 75\nORDER BY \"distance\"\nLIMIT 5;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'London Underground and National Rail services') AS ref_vec_0\n\nSELECT s.network_name, L2Distance(s.services_embedding, ref_vec_0) AS distance\nFROM station s\nJOIN weekly_weather w ON s.id = w.station_id\nWHERE  w.high_temperature > 75\nORDER BY distance\nLIMIT 5;",
        "integration_level": 5.0
    },
    {
        "db_id": "station_weather",
        "sql": "WITH SimilarStations AS (\n    SELECT s.id AS station_id, distance\n    FROM station s\n    WHERE s.services_embedding MATCH lembed(all-MiniLM-L6-v2, \"Metropolitan line and other services\") \n    AND s.k = 5\n)\nSELECT t.train_number\nFROM train t\nJOIN route r ON t.id = r.train_id\nJOIN SimilarStations ss ON r.station_id = ss.station_id\nJOIN weekly_weather w ON r.station_id = w.station_id\nWHERE w.precipitation < 0.1\nORDER BY ss.distance\nLIMIT 1;",
        "sql_result_column_count": 1,
        "sql_result_rows_count": 0,
        "sql_complexity": "Highly Complex",
        "question_style": "Colloquial",
        "sql_explanation": "This SQL query is designed to identify the train number of a train that operates on a route passing through stations offering services similar to those described by the phrase \"Metropolitan line and other services.\" The query uses vector search capabilities provided by the sqlite-lembed extension to find the top 5 stations most aligned with the mentioned services.\n\nThe process begins by creating a common table expression (CTE) `SimilarStations`, which selects station IDs and their distances based on the vector similarity to the phrase \"Metropolitan line and other services.\" The vector search is performed using the `MATCH lembed(all-MiniLM-L6-v2, \"Metropolitan line and other services\")` function and constrained by selecting the top 5 (`s.k = 5`) closest stations.\n\nOnce the similar stations are identified, the query joins the `SimilarStations` CTE with the `train`, `route`, and `weekly_weather` tables to find trains that pass through these stations. Additionally, it filters for days with minimal precipitation, specifically less than 0.1 mm, ensuring that the routes selected are during days with dry weather conditions.\n\nThe results are ordered by the distance to prioritize stations closest in similarity to the services described, and the query limits the results to a single train number (`LIMIT 1`).",
        "question": "Hey, can you help me figure out which train operates on the routes that pass through the top 5 stations offering services like the \"Metropolitan line and other services,\" especially when the weather's dry with almost no rain? I just need the train number.",
        "external_knowledge": "",
        "sqlite_sql": "WITH SimilarStations AS (\n    SELECT s.id AS station_id, distance\n    FROM station s\n    WHERE s.services_embedding MATCH lembed('all-MiniLM-L6-v2', \"Metropolitan line and other services\") \n    AND s.k = 5\n)\nSELECT t.train_number\nFROM train t\nJOIN route r ON t.id = r.train_id\nJOIN SimilarStations ss ON r.station_id = ss.station_id\nJOIN weekly_weather w ON r.station_id = w.station_id\nWHERE w.precipitation < 0.1\nORDER BY ss.distance\nLIMIT 1;",
        "postgresql_sql": "WITH \"SimilarStations\" AS (\n    SELECT \"s\".\"id\" AS \"station_id\", \"s\".\"services_embedding\" <-> lembed('all-MiniLM-L6-v2', 'Metropolitan line and other services') AS \"distance\"\n        FROM \"station\" \"s\"\n    ORDER BY \"distance\"\n    LIMIT 5\n)\n\nSELECT \"t\".\"train_number\"\nFROM \"train\" \"t\"\nJOIN \"route\" \"r\" ON \"t\".\"id\" = \"r\".\"train_id\"\nJOIN \"SimilarStations\" \"ss\" ON \"r\".\"station_id\" = \"ss\".\"station_id\"\nJOIN \"weekly_weather\" \"w\" ON \"r\".\"station_id\" = \"w\".\"station_id\"\nWHERE \"w\".\"precipitation\" < 0.1\nORDER BY \"ss\".\"distance\"\nLIMIT 1;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'Metropolitan line and other services') AS ref_vec_0,\n\nSimilarStations AS (\n    SELECT s.id AS station_id, L2Distance(s.services_embedding, ref_vec_0) AS distance\n        FROM station s\n    ORDER BY distance\n    LIMIT 5\n)\n\nSELECT t.train_number\nFROM train t\nJOIN route r ON t.id = r.train_id\nJOIN SimilarStations ss ON r.station_id = ss.station_id\nJOIN weekly_weather w ON r.station_id = w.station_id\nWHERE w.precipitation < 0.1\nORDER BY ss.distance\nLIMIT 1;",
        "integration_level": 3.0
    },
    {
        "db_id": "station_weather",
        "sql": "SELECT id, network_name\nFROM station\nWHERE services_embedding MATCH lembed(all-MiniLM-L6-v2, \"London Underground and National Rail services\")\nLIMIT 5;",
        "sql_result_column_count": 2,
        "sql_result_rows_count": 5,
        "sql_complexity": "Simple",
        "question_style": "Concise",
        "sql_explanation": "The SQL query is selecting the 'id' and 'network_name' columns from the 'station' table. It uses a vector search operation where the 'services_embedding' column is matched against an embedding generated by 'lembed' using the text \"London Underground and National Rail services\" and the model 'all-MiniLM-L6-v2'. The query limits the results to the top 5 entries that closely match this text, effectively retrieving the stations most associated with \"London Underground and National Rail services\".",
        "question": "What are the IDs and network names of the top 5 stations related to London Underground and National Rail services?",
        "external_knowledge": "",
        "sqlite_sql": "SELECT id, network_name\nFROM station\nWHERE services_embedding MATCH lembed('all-MiniLM-L6-v2', \"London Underground and National Rail services\")\nLIMIT 5;",
        "postgresql_sql": "SELECT \"id\", \"network_name\", \"station\".\"services_embedding\" <-> lembed('all-MiniLM-L6-v2', 'London Underground and National Rail services') AS \"distance\"\nFROM \"station\"\nORDER BY \"distance\"\nLIMIT 5;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'London Underground and National Rail services') AS ref_vec_0\n\nSELECT id, network_name, L2Distance(station.services_embedding, ref_vec_0) AS distance\nFROM station\nORDER BY distance\nLIMIT 5;",
        "integration_level": 2.0
    },
    {
        "db_id": "station_weather",
        "sql": "SELECT t.train_number, s.network_name\nFROM train t\nJOIN route r ON t.id = r.train_id\nJOIN station s ON r.station_id = s.id\nWHERE s.services_embedding MATCH lembed(all-MiniLM-L6-v2, \"London Overground and London Midland\") AND s.k = 3;",
        "sql_result_column_count": 2,
        "sql_result_rows_count": 5,
        "sql_complexity": "Moderate",
        "question_style": "Concise",
        "sql_explanation": "The SQL query aims to find train numbers and network names for trains that pass through stations providing services related to \"London Overground and London Midland\". It achieves this by performing vector similarity search using the `MATCH lembed()` function on the `services_embedding` column to identify stations whose services are most related to the specified text. The query uses `k = 3` to limit the results to the top 3 stations based on this vector similarity. The query involves joining the `train` table with the `route` table and then with the `station` table to filter trains based on the stations' services.",
        "question": "What are the train numbers and network names for the top 3 stations most related to \"London Overground and London Midland\" services?",
        "external_knowledge": "",
        "sqlite_sql": "SELECT t.train_number, s.network_name\nFROM train t\nJOIN route r ON t.id = r.train_id\nJOIN station s ON r.station_id = s.id\nWHERE s.services_embedding MATCH lembed('all-MiniLM-L6-v2', \"London Overground and London Midland\") AND s.k = 3;",
        "postgresql_sql": "SELECT \"t\".\"train_number\", \"s\".\"network_name\", \"s\".\"services_embedding\" <-> lembed('all-MiniLM-L6-v2', 'London Overground and London Midland') AS \"distance\"\nFROM \"train\" \"t\"\nJOIN \"route\" \"r\" ON \"t\".\"id\" = \"r\".\"train_id\"\nJOIN \"station\" \"s\" ON \"r\".\"station_id\" = \"s\".\"id\"\nORDER BY \"distance\"\nLIMIT 3;",
        "clickhouse_sql": "WITH\n    lembed('all-MiniLM-L6-v2', 'London Overground and London Midland') AS ref_vec_0\n\nSELECT t.train_number, s.network_name, L2Distance(s.services_embedding, ref_vec_0) AS distance\nFROM train t\nJOIN route r ON t.id = r.train_id\nJOIN station s ON r.station_id = s.id\nORDER BY distance\nLIMIT 3;",
        "integration_level": 5.0
    }
]